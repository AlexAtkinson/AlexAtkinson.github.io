<header>
  <div class="header-left">
    <div class="avatar-wrap">
      <img
        class="avatar"
        src="assets/images/avatar-alex-in-summer_128.webp"
        srcset="assets/images/avatar-alex-in-summer_128.webp 128w, assets/images/avatar-alex-in-summer_256.webp 256w, assets/images/avatar-alex-in-summer_512.webp 512w"
        sizes="72px"
        width="128"
        height="128"
        alt="Alex Atkinson"
        loading="eager"
        fetchpriority="high"
      >
    </div>
    <div>
      <h1>Alex Atkinson</h1>
      <div class="sub">Dev*Ops, Infra, and Platform Engineering</div>
    </div>
  </div>
  <div class="header-right">
    <div style="display:flex;gap:8px;align-items:center">
      <div class="menu-wrap">
        <button class="hamburger" aria-expanded="false" aria-controls="top-nav" aria-label="Open Navigation Menu" title="Open Navigation Menu">
          <svg width="20" height="14" viewBox="0 0 20 14" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <rect width="20" height="1" y="1" rx="0.5" fill="currentColor" />
            <rect width="20" height="1" y="6" rx="0.5" fill="currentColor" />
            <rect width="20" height="1" y="11" rx="0.5" fill="currentColor" />
          </svg>
        </button>
        <nav id="top-nav" class="menu-dropdown" role="menu" hidden>
          <a role="menuitem" href="/">Home</a>
          <a role="menuitem" href="/articles.html">Articles</a>
          <a role="menuitem" href="/about.html">About</a>
        </nav>
      </div>
    </div>
  </div>
</header>

<script>
// Menu toggle behaviour (will be executed by header-loader after injection)
(function(){
  const wrap = document.querySelector('.menu-wrap');
  if(!wrap) return;
  const btn = wrap.querySelector('.hamburger');
  const menu = wrap.querySelector('.menu-dropdown');
  let closeTimer = null;
  const CLOSE_DELAY = 1000; // ms to wait after mouse-off/blur
  function scheduleClose(){
    clearTimeout(closeTimer);
    closeTimer = setTimeout(() => {
      const pointerOver = wrap.matches(':hover') || btn.matches(':hover') || menu.matches(':hover');
      const active = document.activeElement;
      // only treat anchors or actual menuitem elements as interactive focus that should keep the menu open
      const interactiveFocused = !!(active && (active.tagName === 'A' || (active.closest && active.closest('[role="menuitem"]'))));
      const focusedInside = wrap.contains(active) && interactiveFocused;
      if(!pointerOver && !focusedInside) {
        closeMenu();
      } else {
      }
    }, CLOSE_DELAY);
  }
  function cancelClose(){ clearTimeout(closeTimer); closeTimer = null; }

  function closeMenu(){
    // cancel any pending auto-close timer and close
    cancelClose();
    btn.setAttribute('aria-expanded','false');
    menu.hidden = true;
    wrap.classList.remove('open');
    // remove focus from the button so focus-outline/glow is cleared
    if (document.activeElement === btn) btn.blur();
    // restore accessible label/title
    btn.setAttribute('aria-label', 'Open Navigation Menu');
    btn.setAttribute('title', 'Open Navigation Menu');
  }
  function openMenu(){
    // clear any pending close timer when explicitly opening
    cancelClose();
    btn.setAttribute('aria-expanded','true');
    menu.hidden = false;
    wrap.classList.add('open');
    // do not move focus into the menu automatically (avoid blocking auto-close)
    // keep focus where it was (button) so pointer/hover controls determine auto-close
    btn.focus();
    // update accessible label/title
    btn.setAttribute('aria-label', 'Close Navigation Menu');
    btn.setAttribute('title', 'Close Navigation Menu');
  }
  btn.addEventListener('click', function(e){
    const expanded = btn.getAttribute('aria-expanded') === 'true';
    if(expanded) closeMenu(); else openMenu();
  });
  // close when clicking outside
  document.addEventListener('click', function(e){
    if(!wrap.contains(e.target)) closeMenu();
  });
  // keyboard support
  btn.addEventListener('keydown', function(e){ if(e.key === 'Escape') closeMenu(); });
  menu.addEventListener('keydown', function(e){ if(e.key === 'Escape') { btn.focus(); closeMenu(); } });

  // auto-close: use pointer events + focus events for robustness across input types
  wrap.addEventListener('pointerenter', function(){ cancelClose(); }, {passive:true});
  wrap.addEventListener('pointerleave', function(){ scheduleClose(); }, {passive:true});
  btn.addEventListener('focus', cancelClose);
  btn.addEventListener('blur', scheduleClose);
  menu.addEventListener('focusin', cancelClose);
  menu.addEventListener('focusout', scheduleClose);

  // Mark the current page in the menu: make it visually indicated and non-clickable
  try{
    const links = menu.querySelectorAll('a[role="menuitem"]');
    const normalize = p => (p === '/index.html' ? '/' : (p.replace(/\/$/, '') || '/'));
    const current = normalize(window.location.pathname || window.location.href);
    links.forEach(a => {
      try{
        const hrefPath = new URL(a.getAttribute('href'), window.location.origin).pathname;
        if(normalize(hrefPath) === current){
          a.classList.add('current');
          a.setAttribute('aria-current','page');
          // Remove navigation capability for the current page
          a.removeAttribute('href');
          a.tabIndex = -1;
        }
      }catch(e){}
    });
  }catch(e){}

  // if user clicks/taps outside the menu, start the close timer (but don't close immediately)
  document.addEventListener('pointerdown', function(e){
    // ignore clicks on the theme toggle (and other controls) so they don't trigger menu auto-close
    if(e.target && e.target.closest && e.target.closest('[data-theme-toggle], .theme-toggle')){
      cancelClose();
      return;
    }
    // pointerdown on other elements may schedule/ cancel the menu
    if(!wrap.contains(e.target)) scheduleClose(); else cancelClose();
  }, {passive:true});
})();
</script>
