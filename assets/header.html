<header>
  <div class="header-left">
    <div class="avatar-wrap">
      <img class="avatar" src="assets/images/avatar-alex-in-summer_256.webp" srcset="assets/images/avatar-alex-in-summer_128.webp 128w, assets/images/avatar-alex-in-summer_256.webp 256w, assets/images/avatar-alex-in-summer_512.webp 512w" sizes="(max-width:600px) 64px, 128px" width="128" height="128" alt="Alex Atkinson" loading="eager" fetchpriority="high">
    </div>
    <div>
      <h1>Alex Atkinson</h1>
      <div class="sub">Dev*Ops, Infra, and Platform Engineering</div>
    </div>
  </div>
  <div class="header-right">
    <div style="display:flex;gap:8px;align-items:center">
      <div class="menu-wrap">
        <button class="hamburger" aria-expanded="false" aria-controls="top-nav" aria-label="Open menu">
          <svg width="20" height="14" viewBox="0 0 20 14" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <rect width="20" height="1" y="1" rx="0.5" fill="currentColor" />
            <rect width="20" height="1" y="6" rx="0.5" fill="currentColor" />
            <rect width="20" height="1" y="11" rx="0.5" fill="currentColor" />
          </svg>
        </button>
        <nav id="top-nav" class="menu-dropdown" role="menu" hidden>
          <a role="menuitem" href="/">Home</a>
          <a role="menuitem" href="/articles.html">Articles</a>
        </nav>
      </div>
    </div>
  </div>
</header>

<script>
// Menu toggle behaviour (will be executed by header-loader after injection)
(function(){
  const wrap = document.querySelector('.menu-wrap');
  if(!wrap) return;
  const btn = wrap.querySelector('.hamburger');
  const menu = wrap.querySelector('.menu-dropdown');
  let closeTimer = null;
  const CLOSE_DELAY = 1000; // ms to wait after mouse-off/blur
  function scheduleClose(){
    clearTimeout(closeTimer);
    console.log('menu:scheduleClose - scheduling in', CLOSE_DELAY);
    closeTimer = setTimeout(() => {
      console.log('menu:timer fired - checking state');
      const pointerOver = wrap.matches(':hover') || btn.matches(':hover') || menu.matches(':hover');
      const active = document.activeElement;
      // only treat anchors or actual menuitem elements as interactive focus that should keep the menu open
      const interactiveFocused = !!(active && (active.tagName === 'A' || (active.closest && active.closest('[role="menuitem"]'))));
      const focusedInside = wrap.contains(active) && interactiveFocused;
      console.log('menu:state', {pointerOver, focusedInside, active: active && active.tagName});
      if(!pointerOver && !focusedInside) {
        console.log('menu:closing (timer)');
        closeMenu();
      } else {
        console.log('menu:not closing - user re-entered or focused; not rescheduling');
      }
    }, CLOSE_DELAY);
  }
  function cancelClose(){ clearTimeout(closeTimer); closeTimer = null; }

  function closeMenu(){
    // cancel any pending auto-close timer and close
    cancelClose();
    btn.setAttribute('aria-expanded','false');
    menu.hidden = true;
    wrap.classList.remove('open');
    // remove focus from the button so focus-outline/glow is cleared
    if (document.activeElement === btn) btn.blur();
    console.log('menu:closed');
  }
  function openMenu(){
    // clear any pending close timer when explicitly opening
    cancelClose();
    btn.setAttribute('aria-expanded','true');
    menu.hidden = false;
    wrap.classList.add('open');
    // do not move focus into the menu automatically (avoid blocking auto-close)
    // keep focus where it was (button) so pointer/hover controls determine auto-close
    btn.focus();
    console.log('menu:opened');
  }
  btn.addEventListener('click', function(e){
    const expanded = btn.getAttribute('aria-expanded') === 'true';
    if(expanded) closeMenu(); else openMenu();
  });
  // close when clicking outside
  document.addEventListener('click', function(e){
    if(!wrap.contains(e.target)) closeMenu();
  });
  // keyboard support
  btn.addEventListener('keydown', function(e){ if(e.key === 'Escape') closeMenu(); });
  menu.addEventListener('keydown', function(e){ if(e.key === 'Escape') { btn.focus(); closeMenu(); } });

  // auto-close: use pointer events + focus events for robustness across input types
  wrap.addEventListener('pointerenter', function(){ console.log('menu:pointerenter'); cancelClose(); }, {passive:true});
  wrap.addEventListener('pointerleave', function(){ console.log('menu:pointerleave'); scheduleClose(); }, {passive:true});
  btn.addEventListener('focus', cancelClose);
  btn.addEventListener('blur', scheduleClose);
  menu.addEventListener('focusin', cancelClose);
  menu.addEventListener('focusout', scheduleClose);

  // if user clicks/taps outside the menu, start the close timer (but don't close immediately)
  document.addEventListener('pointerdown', function(e){
    console.log('menu:pointerdown', e.target);
    if(!wrap.contains(e.target)) scheduleClose(); else cancelClose();
  }, {passive:true});
})();
</script>
